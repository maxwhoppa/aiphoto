import { GoogleGenAI } from '@google/genai';
import { config } from '../utils/config';
import { logger } from '../utils/logger';
import { s3Service } from './s3';

export interface GeminiGenerationRequest {
  prompt: string;
  imageUrl?: string;
  scenario?: string;
}

export interface GeminiGenerationResponse {
  requestId: string;
  generatedContent?: string;
  error?: string;
}

export interface GeminiImageGenerationResponse {
  requestId: string;
  imageUrl?: string;
  error?: string;
}

class GeminiService {
  private ai: GoogleGenAI;
  private requestQueue: Array<() => Promise<any>> = [];
  private isProcessingQueue = false;
  private lastRequestTime = 0;
  private minRequestInterval = 1000; // 1 second between requests

  constructor() {
    this.ai = new GoogleGenAI({
      apiKey: config.GOOGLE_GEMINI_API_KEY,
    });
    
    logger.info('Gemini service initialized with gemini-2.5-flash-image-preview (nano banana model)');
  }

  private async sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  private async withRetry<T>(
    operation: () => Promise<T>,
    maxRetries = 3,
    baseDelay = 1000
  ): Promise<T> {
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        // Rate limiting: ensure minimum interval between requests
        const now = Date.now();
        const timeSinceLastRequest = now - this.lastRequestTime;
        if (timeSinceLastRequest < this.minRequestInterval) {
          await this.sleep(this.minRequestInterval - timeSinceLastRequest);
        }
        this.lastRequestTime = Date.now();

        return await operation();
      } catch (error: any) {
        const isRateLimitError = error.message?.includes('429') || error.message?.includes('quota');
        const isLastAttempt = attempt === maxRetries - 1;

        if (isRateLimitError && !isLastAttempt) {
          // Extract retry delay from error if available
          const retryDelayMatch = error.message?.match(/retry in ([\d.]+)s/);
          const suggestedDelay = retryDelayMatch ? parseFloat(retryDelayMatch[1]) * 1000 : baseDelay * Math.pow(2, attempt);
          
          logger.warn(`Rate limit hit, retrying in ${suggestedDelay}ms`, {
            attempt: attempt + 1,
            maxRetries,
            error: error.message,
          });

          await this.sleep(suggestedDelay);
          continue;
        }

        if (isLastAttempt || !isRateLimitError) {
          throw error;
        }
      }
    }
    throw new Error('Max retries exceeded');
  }

  async generateContent(request: GeminiGenerationRequest): Promise<GeminiGenerationResponse> {
    const requestId = this.generateRequestId();
    
    try {
      logger.info('Starting Gemini content generation', {
        requestId,
        scenario: request.scenario,
        hasImage: !!request.imageUrl,
      });

      const response = await this.withRetry(async () => {
        return await this.ai.models.generateContent({
          model: 'gemini-2.5-flash-image-preview',
          contents: [{ text: request.prompt }],
        });
      });

      const candidates = response.candidates;
      if (!candidates || candidates.length === 0) {
        throw new Error('No content generated by Gemini');
      }

      const textPart = candidates[0]?.content?.parts?.find(part => part.text);
      const generatedContent = textPart?.text || '';

      logger.info('Gemini content generation completed', {
        requestId,
        contentLength: generatedContent?.length || 0,
      });

      return {
        requestId,
        generatedContent,
      };
    } catch (error) {
      logger.error('Gemini content generation failed', {
        requestId,
        error: error instanceof Error ? error.message : error,
        stack: error instanceof Error ? error.stack : undefined,
      });

      return {
        requestId,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  async generateImagePrompt(scenario: string, userDescription?: string): Promise<string> {
    const basePrompts: Record<string, string> = {
      photoshoot: 'Professional portrait photography session with studio lighting and modern backdrop',
      nature: 'Outdoor nature setting with natural lighting and scenic landscape background',
      gym: 'Athletic fitness setting with gym equipment and dynamic lighting',
      beach: 'Beach setting with golden hour lighting and ocean backdrop',
      rooftop: 'Urban rooftop setting with city skyline and sunset lighting',
      casual: 'Casual everyday setting with natural lighting and comfortable environment',
    };

    const basePrompt = basePrompts[scenario] || basePrompts.casual;
    
    if (userDescription) {
      return `${basePrompt}. Additional details: ${userDescription}. Create a photorealistic, high-quality image with professional composition.`;
    }

    return `${basePrompt}. Create a photorealistic, high-quality image with professional composition.`;
  }

  async processImageWithScenario(
    originalImageS3Key: string,
    scenario: string,
    customPrompt?: string
  ): Promise<GeminiGenerationResponse> {
    const requestId = this.generateRequestId();

    try {
      logger.info('Starting Gemini image processing', {
        requestId,
        scenario,
        originalImageS3Key,
        hasCustomPrompt: !!customPrompt,
      });

      const prompt = customPrompt || await this.generateImagePrompt(scenario);
      
      // For now, we'll generate a text description
      // In a full implementation, you'd integrate with image generation APIs
      const fullPrompt = `
        Transform the person in this image into the following scenario: ${prompt}
        
        Maintain the person's facial features and appearance while adapting them to the new environment and lighting conditions.
        Provide a detailed description of how the person would look in this new scenario.
      `;

      return await this.generateContent({
        prompt: fullPrompt,
        imageUrl: originalImageS3Key, // This is now an S3 key, not URL
        scenario,
      });
    } catch (error) {
      logger.error('Gemini image processing failed', {
        requestId,
        error: error instanceof Error ? error.message : error,
      });

      return {
        requestId,
        error: error instanceof Error ? error.message : 'Image processing failed',
      };
    }
  }

  async generateAndUploadImage(
    originalImageS3Key: string,
    scenario: string,
    customPrompt?: string,
    s3UploadUrl?: string
  ): Promise<GeminiImageGenerationResponse> {
    const requestId = this.generateRequestId();

    try {
      logger.info('Starting Gemini 2.0 Flash image generation', {
        requestId,
        scenario,
        originalImageS3Key,
        hasCustomPrompt: !!customPrompt,
        hasUploadUrl: !!s3UploadUrl,
      });

      const prompt = customPrompt || await this.generateImagePrompt(scenario);

      // Generate pre-signed download URL for the original image
      const downloadUrlData = await s3Service.generateDownloadUrl(originalImageS3Key, 3600); // 1 hour expiry
      
      // Download the original image using pre-signed URL
      const imageResponse = await fetch(downloadUrlData.downloadUrl);
      if (!imageResponse.ok) {
        throw new Error(`Failed to download original image: ${imageResponse.statusText}`);
      }
      
      const imageBuffer = await imageResponse.arrayBuffer();
      const base64Image = Buffer.from(imageBuffer).toString('base64');

      // Build enhanced prompt for image generation
      const enhancedPrompt = `Transform this person's photo into the following scenario: ${prompt}

Requirements:
- Maintain the person's exact facial features and identity
- Create a photorealistic, high-quality result
- Ensure professional photo quality with natural lighting
- Make it suitable for a dating profile
- Keep the person as the main focus
- Create a believable, authentic-looking transformation

Generate a new image following these specifications.`;

      // Use the correct Google GenAI API pattern
      const promptContent = [
        { text: enhancedPrompt },
        {
          inlineData: {
            mimeType: 'image/jpeg',
            data: base64Image,
          },
        },
      ];

      const response = await this.withRetry(async () => {
        return await this.ai.models.generateContent({
          model: 'gemini-2.5-flash-image-preview',
          contents: promptContent,
        });
      });

      // Check if the response contains generated image data
      const candidates = response.candidates;
      if (!candidates || candidates.length === 0) {
        throw new Error('No image generated by Gemini');
      }

      // Extract generated image data from the response parts
      const parts = candidates[0]?.content?.parts;
      if (!parts) {
        throw new Error('No content parts in Gemini response');
      }

      // Find the image part
      const imagePart = parts.find(part => part.inlineData);
      if (!imagePart?.inlineData?.data) {
        throw new Error('No image data in Gemini response');
      }

      const generatedImageBuffer = Buffer.from(imagePart.inlineData.data, 'base64');

      // Upload to S3 if URL provided
      if (s3UploadUrl) {
        const uploadResponse = await fetch(s3UploadUrl, {
          method: 'PUT',
          body: generatedImageBuffer,
          headers: {
            'Content-Type': 'image/jpeg',
          },
        });

        if (!uploadResponse.ok) {
          throw new Error(`Failed to upload to S3: ${uploadResponse.statusText}`);
        }

        logger.info('Successfully generated and uploaded image', {
          requestId,
          scenario,
          imageSize: generatedImageBuffer.length,
        });

        return {
          requestId,
          imageUrl: s3UploadUrl.split('?')[0], // Remove query params to get final URL
        };
      }

      logger.info('Image generated successfully', {
        requestId,
        scenario,
        imageSize: generatedImageBuffer.length,
      });

      return {
        requestId,
        // Return base64 data if no S3 upload URL provided
        imageUrl: `data:image/jpeg;base64,${imagePart.inlineData.data}`,
      };

    } catch (error) {
      logger.error('Gemini image generation failed', {
        requestId,
        error: error instanceof Error ? error.message : error,
      });

      return {
        requestId,
        error: error instanceof Error ? error.message : 'Image generation failed',
      };
    }
  }

  private generateRequestId(): string {
    return `gemini_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  async healthCheck(): Promise<boolean> {
    try {
      const response = await this.withRetry(async () => {
        return await this.ai.models.generateContent({
          model: 'gemini-2.5-flash-image-preview',
          contents: [{ text: 'Hello, this is a health check.' }],
        });
      });
      return !!(response.candidates && response.candidates.length > 0);
    } catch (error) {
      logger.error('Gemini health check failed', error);
      return false;
    }
  }
}

export const geminiService = new GeminiService();
export default geminiService;